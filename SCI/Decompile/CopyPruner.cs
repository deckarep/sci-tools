using System.Linq;

// CopyPruner is a final pass to remove superfluous nodes that
// may not have existed in the original source, if I can prove
// that no code depends on them.
//
// Examples:
//
// if a then copy [else ...] => if a then empty [else ...]
// cond (a copy) ... => cond (a) ...
// switch (a copy) ... => switch (a) ...
//
// For each of these structure nodes, if a body contains only
// one node and that node is a copy, then figure out if the
// structure node is consumed by its parent. If it is not
// consumed, then delete the copy.
//
// Copies are generated by AstBuilder, but it doesn't have enough
// information to determine if the node existed in source code
// but was optimized out. We can never really know that, but at
// this point we can remove the ones that nobody depends on.

namespace SCI.Decompile.Ast
{
    class CopyPruner : Visitor
    {
        public override void Visit(If if_)
        {
            // only Then is susceptible to being a single copy node
            if (if_.Then.Children.Count == 1 &&
                if_.Then.Children[0].Flags.HasFlag(NodeFlags.Copy))
            {
                if (!IsConsumed(if_))
                {
                    if_.Then.Remove(0);
                }
            }
        }

        public override void Visit(Cond cond)
        {
            // as with If, don't worry about Else.
            // (for the same reason, since Conds started out as Ifs)
            bool? consumed = null;
            foreach (var case_ in cond.Cases)
            {
                if (case_.Body.Children.Count == 1 &&
                    case_.Body.Children[0].Flags.HasFlag(NodeFlags.Copy))
                {
                    // only figure out if cond is consumed once
                    if (consumed == null)
                    {
                        consumed = IsConsumed(cond);
                    }
                    if (!consumed.Value)
                    {
                        case_.Body.Remove(0);
                    }
                }
            }
        }

        public override void Visit(Switch switch_)
        {
            bool? consumed = null;
            foreach (var case_ in switch_.Cases)
            {
                if (case_.Body.Children.Count == 1 &&
                    case_.Body.Children[0].Flags.HasFlag(NodeFlags.Copy))
                {
                    if (consumed == null)
                    {
                        consumed = IsConsumed(switch_);
                    }
                    if (!consumed.Value)
                    {
                        case_.Body.Remove(0);
                    }
                }
            }
            // sure let's handle degenerate switches too!
            if (!switch_.Cases.Any() &&
                switch_.Else != null &&
                switch_.Else.Children.Count == 1 &&
                switch_.Else.Children[0].Flags.HasFlag(NodeFlags.Copy))
            {
                if (consumed == null)
                {
                    consumed = IsConsumed(switch_);
                }
                if (!consumed.Value)
                {
                    switch_.Else.Body.Remove(0);
                }
            }
        }

        bool IsConsumed(Node node)
        {
            if (node.Parent == null) return false;

            var parent = node.Parent;
            int index;
            switch (parent.Type)
            {
                // easy: these parent types consume their children
                case NodeType.ComplexVariable:
                case NodeType.Return: // ReturnAbsorber has sorted this
                case NodeType.Assignment:
                case NodeType.AssignmentAdd:
                case NodeType.AssignmentSub:
                case NodeType.AssignmentMul:
                case NodeType.AssignmentDiv:
                case NodeType.AssignmentShl:
                case NodeType.AssignmentShr:
                case NodeType.AssignmentXor:
                case NodeType.AssignmentBinAnd:
                case NodeType.AssignmentBinOr:
                case NodeType.AddressOf: // n/a i think...
                case NodeType.Not:
                case NodeType.BinNot:
                case NodeType.Neg:
                case NodeType.Add:
                case NodeType.Sub:
                case NodeType.Mul:
                case NodeType.Div:
                case NodeType.Mod:
                case NodeType.Shl:
                case NodeType.Shr:
                case NodeType.Xor:
                case NodeType.BinAnd:
                case NodeType.BinOr:
                case NodeType.And:
                case NodeType.Or:
                case NodeType.Eq:
                case NodeType.Ne:
                case NodeType.Gt:
                case NodeType.Ge:
                case NodeType.Ugt:
                case NodeType.Uge:
                case NodeType.Lt:
                case NodeType.Le:
                case NodeType.Ult:
                case NodeType.Ule:
                case NodeType.BreakIf:
                case NodeType.ContinueIf:
                case NodeType.Send: // Receiver
                case NodeType.SendMessage:
                case NodeType.KernelCall:
                case NodeType.PublicCall:
                case NodeType.LocalCall:
                    return true;

                case NodeType.If:
                    index = parent.Children.IndexOf(node);
                    if (index == 0)
                    {
                        // Test consumes
                        return true;
                    }
                    else
                    {
                        // Then/Else depends on parent. recurse!
                        return IsConsumed(parent);
                    }

                case NodeType.Switch:
                    index = parent.Children.IndexOf(node);
                    if (index == 0)
                    {
                        // Head consumes
                        return true;
                    }
                    else
                    {
                        // Case/Else depends on parent. recurse!
                        return IsConsumed(parent);
                    }

                case NodeType.Cond:
                    // recurse!
                    return IsConsumed(parent);

                case NodeType.Case:
                    index = parent.Children.IndexOf(node);
                    if (index == 0)
                    {
                        // Test consumes
                        return true;
                    }
                    else
                    {
                        // Body depends on parent. recurse!
                        return IsConsumed(parent);
                    }

                case NodeType.Else:
                    // depends on parent. recurse!
                    return IsConsumed(parent);

                case NodeType.Loop:
                    index = parent.Children.IndexOf(node);
                    if (index == 1)
                    {
                        // Test is consumed
                        return true;
                    }
                    else
                    {
                        // Body, Init, and Reinit are not consumed
                        return false;
                    }

                case NodeType.List:
                    // If the node is in a List then it has to be the last node
                    // in the list to be consumed.
                    index = parent.Children.IndexOf(node);
                    if (index != parent.Children.Count - 1)
                    {
                        return false;
                    }
                    else
                    {
                        // depends on parent. recurse!
                        return IsConsumed(parent);
                    }

                default:
                    return false;
            }
        }
    }
}
